---
title: Authentication Configuration
description: Configure authentication methods for your Memos instance, including sessions, tokens, and OAuth SSO.
---

Configure authentication for your Memos instance. Administrator access required.

## Overview

Memos supports three authentication methods:

- **Sessions**: Cookie-based auth for web browsers (14-day sliding expiration)
- **Access Tokens**: JWT tokens for apps, scripts, and APIs
- **OAuth SSO**: Single Sign-On with GitHub, Google, GitLab, or custom providers

**Authentication priority:** Requests are checked in order: session cookie → JWT token → public endpoint → 401 error.

## Sessions

Cookie-based authentication for web browsers. Sessions automatically extend with each use (14-day sliding window).

**Configuration:**
- Cookie name: `user_session`
- HttpOnly: Yes (XSS protection)
- Secure: Yes (HTTPS only in production)
- SameSite: Strict/None based on HTTPS
- Expiration: 14 days from last activity

**Session tracking:** Device type, browser, OS, IP address, creation time, last access time.

**Management:** Users manage sessions in Settings → Sessions (view all devices, revoke individual sessions, logout from all devices).

<Callout type="info">
Sessions automatically track device info and last access for security auditing.
</Callout>

## Access Tokens

JWT-based tokens for programmatic API access. Don't expire from inactivity.

**Token creation:** Users create tokens in Settings → Access Tokens with optional expiration (7/30/90/365 days or never).

**Usage:** Include in `Authorization` header:
```bash
curl -H "Authorization: Bearer YOUR_TOKEN" \
  https://memos.example.com/api/v1/memos
```

**Code examples:**

Python:
```python
import requests
headers = {"Authorization": f"Bearer {token}"}
response = requests.get("https://memos.example.com/api/v1/memos", headers=headers)
```

JavaScript:
```javascript
const response = await fetch("https://memos.example.com/api/v1/memos", {
  headers: { "Authorization": `Bearer ${token}` }
});
```

**Recommended expiration:**

| Use Case | Expiration |
|----------|-----------|
| Mobile apps | 30-90 days |
| Desktop apps | 90-365 days |
| CI/CD scripts | 90-365 days |
| Testing | 7-30 days |

**Security best practices:** One token per device/app, use descriptive names, set expiration dates, rotate regularly, store in secure vaults (never in git), revoke when no longer needed.

**Secure storage:**
- Mobile: iOS Keychain / Android Keystore
- Desktop: OS keychain/credential manager
- CLI: Config file with `chmod 600`
- CI/CD: Environment variables or secret managers

<Callout type="error">
Tokens are displayed only once during creation. Store securely.
</Callout>

## Local Authentication

Traditional username/password login, enabled by default.

**Password security:** bcrypt hashing, never stored in plain text, unique salt per password, resistant to rainbow table attacks.

**User registration control:** Configure in Settings → Workspace:
- Allow User Registration: Enable/disable public signups
- Disable Password Auth: Force OAuth-only mode

<Callout type="info">
Existing users keep password access when OAuth-only mode is enabled.
</Callout>

## OAuth SSO

Single Sign-On with external identity providers.

**Benefits:** No additional password, leverage provider's 2FA, centralized account management, instant user onboarding.

**Setup (administrators only):**
1. Create OAuth app in your provider (GitHub, Google, GitLab)
2. Navigate to Settings → Identity Providers
3. Click "Add Identity Provider"
4. Enter Client ID and Secret
5. Set callback URL: `https://your-domain.com/api/v1/auth/callback`
6. Configure field mapping
7. Test configuration

**Provider configurations:**

GitHub:
```
Type: GITHUB
Scopes: ["read:user", "user:email"]
Field Mapping: login, name, email
```

Google:
```
Type: GOOGLE
Scopes: ["openid", "profile", "email"]
Field Mapping: email, name, email
```

GitLab:
```
Type: GITLAB
Scopes: ["read_user"]
Field Mapping: name, name, email
```

Custom OAuth 2.0:
```
Type: CUSTOM
Configure: Auth URL, Token URL, User Info URL
Scopes: Provider-specific
Field Mapping: Custom (identifier, name, email)
```

**Identifier filtering:** Restrict access with regex patterns:
```bash
# Organization filter
"^org-.*"

# Email domain filter
".*@company\\.com$"

# Specific users
"^(user1|user2|user3)$"
```

**User provisioning:** First-time OAuth login creates account automatically with "USER" role, profile populated from provider.

<Callout type="warning">
Only administrators can configure OAuth providers in Settings → Identity Providers.
</Callout>

## User Roles

Role-based access control:

- **HOST**: Full system access, manages all users and settings
- **ADMIN**: Administrative access with user management
- **USER**: Standard user access with personal memo management

## Security

**Session security:**
- HttpOnly cookies (prevents JavaScript access)
- SameSite attribute (CSRF protection)
- Secure flag (HTTPS in production)
- Automatic validation per request

**Password security:**
- bcrypt hashing with unique salts
- Never stored in plain text
- Resistant to rainbow table attacks

**Access control:**
- JWT tokens for API authentication
- ACL middleware validates protected endpoints
- Session and token validation per request

<Callout type="info">
Multi-Factor Authentication (MFA) is planned for a future release.
</Callout>

## Testing

Test local authentication:
```bash
curl -X POST "https://your-domain.com/api/v1/auth/signin" \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser","password":"testpass"}'
```

Test token authentication:
```bash
curl -H "Authorization: Bearer YOUR_TOKEN" \
  https://your-domain.com/api/v1/memos
```

Test session management:
```bash
# Login with cookie
curl -X POST "https://your-domain.com/api/v1/auth/signin" \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser","password":"testpass"}' \
  -c cookies.txt

# Verify session
curl -X GET "https://your-domain.com/api/v1/auth/me" -b cookies.txt
```

Test OAuth:
```bash
curl -I "https://your-domain.com/api/v1/auth/oauth/github"
```

## Troubleshooting

**Session issues:**
- Sessions expire after 14 days of inactivity
- Enable cookies (not private/incognito mode)
- Check device time/date is correct
- Verify SSL certificate (if HTTPS)
- Clear browser cache and retry

**Token issues:**
- Verify token not expired (Settings → Access Tokens)
- Use format: `Authorization: Bearer YOUR_TOKEN`
- Check token not revoked
- Ensure no extra spaces or line breaks

**OAuth issues:**
- Verify OAuth app credentials correct
- Check callback URL: `https://your-domain.com/api/v1/auth/callback`
- Ensure OAuth app not in dev/test mode
- Verify identifier filter matches username/email

**Security concerns:**

Unknown session:
1. Settings → Sessions → Review all
2. Revoke unrecognized sessions
3. Change password immediately

Token compromised:
1. Settings → Access Tokens → Revoke all
2. Create new tokens for trusted apps
3. Review recent activity
4. Change password

Need help? [GitHub Issues](https://github.com/usememos/memos/issues) • [Discussions](https://github.com/usememos/memos/discussions)
